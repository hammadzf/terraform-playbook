# Terraform Basics
This section covers the basic building blocks of Terraform, which we'll see in the [Working with Terraform (link TBD)](TBD) section. 

## Terraform providers
Terraform providers can be found in the [Terraform registry](https://registry.terraform.io/). These providers are divided into the following categories:
- **Official:** Maintained by Hashicorp (e.g., AWS, GCP, Azure, Alibaba, Local providers)
- **Partner:** Maintained by partner communities (e.g., MongoDB, DigitalOcean providers) 
- **Community:** Published and maintained by the community

The required Terraform providers are installed during `terraform init` command based on the configurations defined in `main.tf`.

## Variables
Variables can be used instead of providing values directly in the configuration files. These variables can be defined separately in a `variables.tf` file. This way configuration files can be reused and only values in the variable file will need updating.

### Variable Types
- **Basic variable types:** string, boolean and number
- **Complex types:** lists, sets (similar to lists but no duplicate values), map (key value dictionary), object (similar to C structs), tuples (three values of specific types can be passed using a tuple variable)

### Defining Variables
There are various ways to define variables in Terraform: using variables file, environment variables, using `terraform.tfvars`/`terraform.tfvars.json` file, or any file ending with `*.auto.tfvars` or even using CLI when running terraform apply command. 

**Examples (variable definition via files)**
```hcl
variable "filename" {
     type = string  
     default = "./example.txt"
}

variable "distance" {
     type = number
     default = 5 
}

variable "hard_drive" {
     type = map
     default = {
          slow = "HHD"
          fast = "SSD"
     }
}

variable "users" {
     type = set(string)
     default = ["tom", "jerry"]
}

```

Variables can be used in resource arguments like this:

```hcl
resource "local_file" "example" {
  filename = var.filename
  content =  var.users
}

variable "filename" {
     type = string  
     default = "./example.txt"
}

variable "users" {
     type = set(string)
     default = ["tom", "jerry"]
} 
```

The sequence of precedence that Terraform follows for variables that are assigned multiple times is as follows (with higher values in the list superseding previous ones):
1. variables defined as environment variables
2. variables in `terraform.tfvars` file
3. variables in `*.auto.tfvars` files (in alphabetical order)
4. variables defined via command line when running terraform commands

## Referencing Resource Attributes
Resource attributes can be referenced inside other terraform resources using this syntax: `${<resource_type>.<resource_name>.<attribute_name>}`. Terraform follows something called interpolation sequence during referencing, which means the referenced attribute is converted into an appropriate type (e.g., string) before being merged into the content where it’s being referenced.

Values of variables can be used 

**Example:**
```hcl
resource "time_static" "time_update" {
}

resource "local_file" "time" {
  filename = "./time.txt"
  content = "Time stamp of this file is ${time_static.time_update.id}"
}
```
Another example can be seen [here](./examples/referencing.tf).

The referenced attribute can also belong to a resource that hasn’t been created yet (but it should be present inthe configuration files). Referencing by expressions (like using the syntax shown above) implies "implicit dependency" between resources. Another way is "explicit dependency" using the the "depends_on" argument. However, referencing expression is still needed for referencing an attribute in the dependent resource. 

## Output variables
Output blocks can be defined to store values, reuse them in other resources, or to forward them to external non-Terraform tools like Ansible etc.

**Example:**
```hcl
output "pet-name" {
	value = random_pet.my-pet.id
	description = "Record the value of pet ID generated by the random_pet resource"
}
```

## Terraform State
Terraform maintains state of all the created resources (after the initial apply stage) and refers to this state whenever a new ‘plan’ or ‘apply’ stage occurs. Deltas are determined between the actual state and new desired configurations. Application of new configuration is only done for those resources that require changes. Newly created or updated resources are then also stored in the terraform state file.

`terraform.tfstate` file contains the state of infrastructure by mapping the real-world infrastructure in the state file. Metadata associated with the resources is also maintained in the state file. 

### Remote State
Terraform state acts as the single source of truth in Terraform. It is a non-optional feature. State file contains sensitive information and every little detail about the real-world infrastructure. There can be ways to store state in remote backends, e.g., Terraform HCP, Hashicorp Consul, Kubernetes, Google Cloud, etc. 

Team members working on same infrastructure can share the single state (stored remotely) among them instead of relying on their local copies. As best practice, configuration files are stored in a version control environment like GitHub, GitLab etc.

### Potential Issues
Reconciliation between state in `terraform.tfstate` and actual infrastructure can cause performance issues in large-scale, distributed infrastructure offered by multiple providers. Reconciliation can be avoided by just relying on cache and not refreshing state again and again with each ‘apply’ stage (using the `-refresh=false` flag when running plan and apply). This can however lead to configuration drift. 
